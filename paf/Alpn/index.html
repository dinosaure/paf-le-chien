<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Alpn (paf.Alpn)</title><link rel="stylesheet" href="../../_odoc_support/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.2.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../_odoc_support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../index.html">paf</a> &#x00BB; Alpn</nav><header class="odoc-preamble"><h1>Module <code><span>Alpn</span></code></h1><p>ALPN support.</p><p><code>Alpn</code> depend on <code>http/af</code> &amp; <code>h2</code> and choose them because they share the same <a href="../Paf/module-type-RUNTIME/index.html"><code>Paf.RUNTIME</code></a> interface. <code>Alpn</code> does not require <code>ocaml-tls</code> so it's possible to use OpenSSL. It requires, at least:</p><ul><li>Something to extract ALPN result from the TLS <i>flow</i></li><li>Something to represent as the string the peer (useful for over-framework)</li><li>An injection function (available from <code>mimic</code>)</li></ul><p>In other words, <code>Alpn</code> did the only choice to trust on <code>http/af</code> &amp; <code>h2</code> to handle HTTP/1.0, HTTP/1.1 and H2 protocols.</p></header><div class="odoc-content"><div class="odoc-spec"><div class="spec module-type anchored" id="module-type-REQD"><a href="#module-type-REQD" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-REQD/index.html">REQD</a></span><span> = <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-http_1_1_protocol"><a href="#type-http_1_1_protocol" class="anchor"></a><code><span><span class="keyword">type</span> http_1_1_protocol</span><span> =
  <span>(<span class="keyword">module</span> <a href="module-type-REQD/index.html">REQD</a>
  <span class="keyword">with</span> <span class="keyword">type</span> <a href="module-type-REQD/index.html#type-request">request</a> = <span class="xref-unresolved">Httpaf</span>.Request.t
   <span class="keyword">and</span> <span class="keyword">type</span> <a href="module-type-REQD/index.html#type-response">response</a> = <span class="xref-unresolved">Httpaf</span>.Response.t
   <span class="keyword">and</span> <span class="keyword">type</span> <a href="module-type-REQD/index.html#type-t">t</a> = <span class="xref-unresolved">Httpaf</span>.Reqd.t
   <span class="keyword">and</span> <span class="keyword">type</span> <a href="module-type-REQD/Body/index.html#type-ro">Body.ro</a> = <span><span>[ `read ]</span> <span class="xref-unresolved">Httpaf</span>.Body.t</span>
   <span class="keyword">and</span> <span class="keyword">type</span> <a href="module-type-REQD/Body/index.html#type-wo">Body.wo</a> = <span><span>[ `write ]</span> <span class="xref-unresolved">Httpaf</span>.Body.t</span>)</span></span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-h2_protocol"><a href="#type-h2_protocol" class="anchor"></a><code><span><span class="keyword">type</span> h2_protocol</span><span> =
  <span>(<span class="keyword">module</span> <a href="module-type-REQD/index.html">REQD</a>
  <span class="keyword">with</span> <span class="keyword">type</span> <a href="module-type-REQD/index.html#type-request">request</a> = <span class="xref-unresolved">H2</span>.Request.t
   <span class="keyword">and</span> <span class="keyword">type</span> <a href="module-type-REQD/index.html#type-response">response</a> = <span class="xref-unresolved">H2</span>.Response.t
   <span class="keyword">and</span> <span class="keyword">type</span> <a href="module-type-REQD/index.html#type-t">t</a> = <span class="xref-unresolved">H2</span>.Reqd.t
   <span class="keyword">and</span> <span class="keyword">type</span> <a href="module-type-REQD/Body/index.html#type-ro">Body.ro</a> = <span class="xref-unresolved">H2</span>.Body.Reader.t
   <span class="keyword">and</span> <span class="keyword">type</span> <a href="module-type-REQD/Body/index.html#type-wo">Body.wo</a> = <span class="xref-unresolved">H2</span>.Body.Writer.t)</span></span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-protocol"><a href="#type-protocol" class="anchor"></a><code><span><span class="keyword">type</span> <span>('reqd, 'headers, 'request, 'response, 'ro, 'wo) protocol</span></span><span> = </span></code><ol><li id="type-protocol.HTTP_1_1" class="def variant constructor anchored"><a href="#type-protocol.HTTP_1_1" class="anchor"></a><code><span>| </span><span><span class="constructor">HTTP_1_1</span> : <a href="#type-http_1_1_protocol">http_1_1_protocol</a> <span class="arrow">&#45;&gt;</span> <span><span>(<span class="xref-unresolved">Httpaf</span>.Reqd.t,
                                  <span class="xref-unresolved">Httpaf</span>.Headers.t,
                                  <span class="xref-unresolved">Httpaf</span>.Request.t,
                                  <span class="xref-unresolved">Httpaf</span>.Response.t,
                                  <span><span>[ `read ]</span> <span class="xref-unresolved">Httpaf</span>.Body.t</span>,
                                  <span><span>[ `write ]</span> <span class="xref-unresolved">Httpaf</span>.Body.t</span>)</span>
                                  <a href="#type-protocol">protocol</a></span></span></code></li><li id="type-protocol.H2" class="def variant constructor anchored"><a href="#type-protocol.H2" class="anchor"></a><code><span>| </span><span><span class="constructor">H2</span> : <a href="#type-h2_protocol">h2_protocol</a> <span class="arrow">&#45;&gt;</span> <span><span>(<span class="xref-unresolved">H2</span>.Reqd.t,
                      <span class="xref-unresolved">H2</span>.Headers.t,
                      <span class="xref-unresolved">H2</span>.Request.t,
                      <span class="xref-unresolved">H2</span>.Response.t,
                      <span class="xref-unresolved">H2</span>.Body.Reader.t,
                      <span class="xref-unresolved">H2</span>.Body.Writer.t)</span>
                      <a href="#type-protocol">protocol</a></span></span></code></li></ol></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-http_1_1"><a href="#val-http_1_1" class="anchor"></a><code><span><span class="keyword">val</span> http_1_1 : 
  <span><span>(<span class="xref-unresolved">Httpaf</span>.Reqd.t,
    <span class="xref-unresolved">Httpaf</span>.Headers.t,
    <span class="xref-unresolved">Httpaf</span>.Request.t,
    <span class="xref-unresolved">Httpaf</span>.Response.t,
    <span><span>[ `read ]</span> <span class="xref-unresolved">Httpaf</span>.Body.t</span>,
    <span><span>[ `write ]</span> <span class="xref-unresolved">Httpaf</span>.Body.t</span>)</span>
    <a href="#type-protocol">protocol</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-h2"><a href="#val-h2" class="anchor"></a><code><span><span class="keyword">val</span> h2 : 
  <span><span>(<span class="xref-unresolved">H2</span>.Reqd.t,
    <span class="xref-unresolved">H2</span>.Headers.t,
    <span class="xref-unresolved">H2</span>.Request.t,
    <span class="xref-unresolved">H2</span>.Response.t,
    <span class="xref-unresolved">H2</span>.Body.Reader.t,
    <span class="xref-unresolved">H2</span>.Body.Writer.t)</span>
    <a href="#type-protocol">protocol</a></span></span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-server_error"><a href="#type-server_error" class="anchor"></a><code><span><span class="keyword">type</span> server_error</span><span> = </span><span>[ </span></code><ol><li id="type-server_error.Bad_gateway" class="def constructor anchored"><a href="#type-server_error.Bad_gateway" class="anchor"></a><code><span>| </span></code><code><span>`Bad_gateway</span></code></li><li id="type-server_error.Bad_request" class="def constructor anchored"><a href="#type-server_error.Bad_request" class="anchor"></a><code><span>| </span></code><code><span>`Bad_request</span></code></li><li id="type-server_error.Exn" class="def constructor anchored"><a href="#type-server_error.Exn" class="anchor"></a><code><span>| </span></code><code><span>`Exn <span class="keyword">of</span> exn</span></code></li><li id="type-server_error.Internal_server_error" class="def constructor anchored"><a href="#type-server_error.Internal_server_error" class="anchor"></a><code><span>| </span></code><code><span>`Internal_server_error</span></code></li></ol><code><span> ]</span></code></div><div class="spec-doc"><p>Type of server errors.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-info"><a href="#type-info" class="anchor"></a><code><span><span class="keyword">type</span> <span>('flow, 'edn) info</span></span><span> = </span><span>{</span></code><ol><li id="type-info.alpn" class="def record field anchored"><a href="#type-info.alpn" class="anchor"></a><code><span>alpn : <span><span class="type-var">'flow</span> <span class="arrow">&#45;&gt;</span></span> <span>string option</span>;</span></code></li><li id="type-info.peer" class="def record field anchored"><a href="#type-info.peer" class="anchor"></a><code><span>peer : <span><span class="type-var">'flow</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'edn</span>;</span></code></li><li id="type-info.injection" class="def record field anchored"><a href="#type-info.injection" class="anchor"></a><code><span>injection : <span><span class="type-var">'flow</span> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Mimic</span>.flow;</span></code></li></ol><code><span>}</span></code></div><div class="spec-doc"><p>The type of information from a <code>'flow</code>:</p><ul><li><code>alpn</code> is a function which is able to extract the result of the negotiation between the client &amp; the server about which protocol we need to use.</li><li><code>peer</code> returns a <code>string</code> representation of the given <code>'flow</code> to help to print out some logs about this client.</li><li><code>injection</code> is the function which wraps the given <code>'flow</code> to a <code>Mimic.flow</code>.</li></ul><p>For the last function, it can be done if you already registered the protocol with <code>mimic</code>. In that case, the second value given by <code>Mimic.register</code> helps you to <i>inject</i> your flow as a <code>Mimic.flow</code>:</p><pre class="language-ocaml"><code>let _, protocol = Mimic.register ~name:&quot;my-protocol&quot; (module My_protocol)

let injection (flow : My_protocol.flow) : Mimic.flow =
  let module R = (val Mimic.repr protocol) in
  R.T flow</code></pre></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-server_handler"><a href="#type-server_handler" class="anchor"></a><code><span><span class="keyword">type</span> <span>('flow, 'edn) server_handler</span></span><span> = </span><span>{</span></code><ol><li id="type-server_handler.error" class="def record field anchored"><a href="#type-server_handler.error" class="anchor"></a><code><span>error : 'reqd 'headers 'request 'response 'ro 'wo. <span><span class="type-var">'edn</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'reqd</span>, <span class="type-var">'headers</span>, <span class="type-var">'request</span>, <span class="type-var">'response</span>, <span class="type-var">'ro</span>, <span class="type-var">'wo</span>)</span> <a href="#type-protocol">protocol</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span>?request:<span class="type-var">'request</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-server_error">server_error</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span class="type-var">'headers</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'wo</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  unit;</span></code></li><li id="type-server_handler.request" class="def record field anchored"><a href="#type-server_handler.request" class="anchor"></a><code><span>request : 'reqd 'headers 'request 'response 'ro 'wo. <span><span class="type-var">'flow</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'edn</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'reqd</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'reqd</span>, <span class="type-var">'headers</span>, <span class="type-var">'request</span>, <span class="type-var">'response</span>, <span class="type-var">'ro</span>, <span class="type-var">'wo</span>)</span> <a href="#type-protocol">protocol</a></span> <span class="arrow">&#45;&gt;</span></span>
  unit;</span></code></li></ol><code><span>}</span></code></div><div class="spec-doc"><p>The type of handler. To be able to handle http/1.1 and h2 requests with the same function, we have chosen to use record with universally quantified types. Such design requires some constraints: 1) <code>error</code> and <code>request</code> should be defined at top 2) if they requires extra informations (such as the path of file, a value to connect to a database, etc.), they can be used into handlers but the record must contains non-curried version of these handlers. 3) you must use type annotation due to the GADT <a href="#type-protocol"><code>protocol</code></a></p><p>For instance, we have a value <code>db</code> is required by our request handler. You can describe your handler by this way:</p><pre class="language-ocaml"><code>let error_handler
  : type reqd headers request response ro wo.
    _ -&gt; (reqd, headers, request, response, ro, wo) Alpn.protocol -&gt;
    ?request:request -&gt; _ -&gt; (headers -&gt; wo) -&gt; unit
  = fun edn protocol ?request error respond -&gt;
    match protocol with
    | Alpn.HTTP_1_1 _ -&gt;
      (* everything is specialized to the [Httpaf] module. You can use
         [?request] as an [Httpaf.Request.t option] without type error. *)
    | Alpn.H2 _ -&gt;
      (* everything is specialized to the [H2] module. *)

let request_handler
  : type reqd headers request response ro wo.
    Database.t -&gt; _ -&gt; _ -&gt; reqd -&gt;
    (reqd, headers, request, response, ro, wo) Alpn.protocol -&gt; unit
  = fun db flow edn reqd -&gt; function
  | Alpn.HTTP_1_1 _ -&gt; ...
  | Alpn.H2 _ -&gt; ...

let handler db =
  { error= (fun edn protocol ?request error respond -&gt;
          error_handler edn protocol ?request error respond)
  ; request= (fun flow edn reqd protocol -&gt;
          request_handler db flow end reqd protocol) }</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-service"><a href="#val-service" class="anchor"></a><code><span><span class="keyword">val</span> service : 
  <span><span><span>(<span class="type-var">'flow</span>, <span class="type-var">'edn</span>)</span> <a href="#type-info">info</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="xref-unresolved">Mimic</span>.flow, <span class="type-var">'edn</span>)</span> <a href="#type-server_handler">server_handler</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span class="type-var">'socket</span> <span class="arrow">&#45;&gt;</span></span>
    <span><span><span>(<span class="type-var">'flow</span>, <span>[&gt; `Closed <span><span>| `Msg</span> of string</span> ]</span> <span class="keyword">as</span> 'error)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span class="type-var">'t</span> <span class="arrow">&#45;&gt;</span></span>
    <span><span><span>(<span class="type-var">'socket</span>, <span>[&gt; `Closed <span><span>| `Msg</span> of string</span> ]</span> <span class="keyword">as</span> 'error)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span class="type-var">'t</span> <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'t</span> <a href="../Paf/index.html#type-service">Paf.service</a></span></span></code></div><div class="spec-doc"><p><code>service info handler connect accept close</code> creates a new <a href="../Paf/index.html#type-service"><code>Paf.service</code></a> over the <i>socket</i> <code>'flow</code>. From the given implementation of <code>accept</code> and <code>close</code>, we are able to instantiate the <i>main loop</i>. Then, from the given <code>info</code>, we extract informations such the application layer protocol and choose which protocol we will use. Currently, if <code>info.alpn</code> returns:</p><ul><li><code>Some &quot;http/1.0&quot; | Some &quot;http/1.1&quot; | None</code>, we launch an <code>http/af</code> service</li><li><code>Some &quot;h2&quot;</code>, we launch an <code>h2</code> service</li></ul><p>The user is able to identify which protocol we launched by <a href="#type-server_handler"><code>server_handler</code></a>. The returned service can be run with <a href="../Paf/index.html#val-serve"><code>Paf.serve</code></a>. Here is an example with <code>Lwt_unix.file_descr</code> and the TCP/IP transmission protocol (without ALPN negotiation):</p><pre class="language-ocaml"><code>let _, protocol
  : Unix.sockaddr Mimic.value
    * (Unix.sockaddr, Lwt_unix.file_descr) Mimic.protocol
  = Mimic.register ~name:&quot;lwt-tcp&quot; (module TCP)

let accept t =
  Lwt.catch begin fun () -&gt;
    Lwt_unix.accept &gt;&gt;= fun (socket, _) -&gt;
    Lwt.return_ok socket
  end @@ function
  | Unix.Unix_error (err, f, v) -&gt;
    Lwt.return_error (`Unix (err, f, v))
  | exn -&gt; raise exn

let info =
  let module R = (val Mimic.register protocol) in
  { Alpn.alpn= const None
  ; Alpn.peer= (fun socket -&gt;
    sockaddr_to_string (Lwt_unix.getpeername socket))
  ; Alpn.injection=
    (fun socket -&gt; R.T socket) }

let service = Alpn.service info handler
  accept Lwt_unix.close

let fiber =
  let t = Lwt_unix.socket Unix.PF_INET Unix.SOCK_STREAM 0 in
  Lwt_unix.bind t (Unix.ADDR_INET (Unix.inet_addr_loopback, 8080))
  &gt;&gt;= fun () -&gt;
  let `Initialized th = Paf.serve service t in th

let () = Lwt_main.run fiber</code></pre></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-client_error"><a href="#type-client_error" class="anchor"></a><code><span><span class="keyword">type</span> client_error</span><span> = </span><span>[ </span></code><ol><li id="type-client_error.Exn" class="def constructor anchored"><a href="#type-client_error.Exn" class="anchor"></a><code><span>| </span></code><code><span>`Exn <span class="keyword">of</span> exn</span></code></li><li id="type-client_error.Malformed_response" class="def constructor anchored"><a href="#type-client_error.Malformed_response" class="anchor"></a><code><span>| </span></code><code><span>`Malformed_response <span class="keyword">of</span> string</span></code></li><li id="type-client_error.Invalid_response_body_length_v1" class="def constructor anchored"><a href="#type-client_error.Invalid_response_body_length_v1" class="anchor"></a><code><span>| </span></code><code><span>`Invalid_response_body_length_v1 <span class="keyword">of</span> <span class="xref-unresolved">Httpaf</span>.Response.t</span></code></li><li id="type-client_error.Invalid_response_body_length_v2" class="def constructor anchored"><a href="#type-client_error.Invalid_response_body_length_v2" class="anchor"></a><code><span>| </span></code><code><span>`Invalid_response_body_length_v2 <span class="keyword">of</span> <span class="xref-unresolved">H2</span>.Response.t</span></code></li><li id="type-client_error.Protocol_error" class="def constructor anchored"><a href="#type-client_error.Protocol_error" class="anchor"></a><code><span>| </span></code><code><span>`Protocol_error <span class="keyword">of</span> <span class="xref-unresolved">H2</span>.Error_code.t * string</span></code></li></ol><code><span> ]</span></code></div><div class="spec-doc"><p>Type of client errors.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-client_handler"><a href="#type-client_handler" class="anchor"></a><code><span><span class="keyword">type</span> <span>'edn client_handler</span></span><span> = </span><span>{</span></code><ol><li id="type-client_handler.error" class="def record field anchored"><a href="#type-client_handler.error" class="anchor"></a><code><span>error : 'reqd 'headers 'request 'response 'ro 'wo. <span><span class="type-var">'edn</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'reqd</span>, <span class="type-var">'headers</span>, <span class="type-var">'request</span>, <span class="type-var">'response</span>, <span class="type-var">'ro</span>, <span class="type-var">'wo</span>)</span> <a href="#type-protocol">protocol</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-client_error">client_error</a> <span class="arrow">&#45;&gt;</span></span>
  unit;</span></code></li><li id="type-client_handler.response" class="def record field anchored"><a href="#type-client_handler.response" class="anchor"></a><code><span>response : 'reqd 'headers 'request 'response 'ro 'wo. <span><span class="xref-unresolved">Mimic</span>.flow <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'edn</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'response</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'ro</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'reqd</span>, <span class="type-var">'headers</span>, <span class="type-var">'request</span>, <span class="type-var">'response</span>, <span class="type-var">'ro</span>, <span class="type-var">'wo</span>)</span> <a href="#type-protocol">protocol</a></span> <span class="arrow">&#45;&gt;</span></span>
  unit;</span></code></li></ol><code><span>}</span></code></div><div class="spec-doc"><p>The type of client handler. As <a href="#type-server_handler"><code>server_handler</code></a>, we have chosen to use a record with universally quantified types. Please follow the explanation given about <a href="#type-server_handler"><code>server_handler</code></a> to understand how to use it.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-alpn_response"><a href="#type-alpn_response" class="anchor"></a><code><span><span class="keyword">type</span> alpn_response</span><span> = </span></code><ol><li id="type-alpn_response.Response_HTTP_1_1" class="def variant constructor anchored"><a href="#type-alpn_response.Response_HTTP_1_1" class="anchor"></a><code><span>| </span><span><span class="constructor">Response_HTTP_1_1</span> : <span>(<span><span>[ `write ]</span> <span class="xref-unresolved">Httpaf</span>.Body.t</span> * <span class="xref-unresolved">Httpaf</span>.Client_connection.t)</span> <span class="arrow">&#45;&gt;</span> 
  <a href="#type-alpn_response">alpn_response</a></span></code></li><li id="type-alpn_response.Response_H2" class="def variant constructor anchored"><a href="#type-alpn_response.Response_H2" class="anchor"></a><code><span>| </span><span><span class="constructor">Response_H2</span> : <span class="xref-unresolved">H2</span>.Body.Writer.t * <span class="xref-unresolved">H2</span>.Client_connection.t <span class="arrow">&#45;&gt;</span> <a href="#type-alpn_response">alpn_response</a></span></code></li></ol></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-run"><a href="#val-run" class="anchor"></a><code><span><span class="keyword">val</span> run : 
  <span>?alpn:string <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'edn</span> <a href="#type-client_handler">client_handler</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'edn</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>[ <span>`V1 of <span class="xref-unresolved">Httpaf</span>.Request.t</span> <span><span>| `V2</span> of <span class="xref-unresolved">H2</span>.Request.t</span> ]</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Mimic</span>.flow <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<a href="#type-alpn_response">alpn_response</a>, <span>[&gt; <span>`Msg of string</span> ]</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>run ?alpn ~client_handler edn req flow</code> tries communicate to <code>edn</code> via <code>flow</code> with a certain protocol according to the given <code>alpn</code> value and the given request. It returns the body of the request to allow the user to write on it (and communicate then with the server).</p><p><code>run</code> does only the ALPN dispatch. It does not instantiate the connection and it does not try to upgrade the protocol. It just choose the right HTTP protocol according to:</p><ul><li>the given <code>alpn</code> value</li><li>the given <code>request</code> (if you want to communicate via HTTP/1.1 or H2)</li></ul><p>Here is an example with <code>mimic</code>:</p><pre class="language-ocaml"><code>let run uri request =
  let ctx = ctx_of_uri uri in
  (* See Mimic for more details. *)
  Mimic.resolve ctx &gt;&gt;= function
  | Error _ as err -&gt; Lwt.return err
  | Ok flow -&gt; run ?alpn:None handler uri request flow</code></pre></div></div></div></body></html>