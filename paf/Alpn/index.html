<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Alpn (paf.Alpn)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.1.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../index.html">paf</a> &#x00BB; Alpn</nav><header class="odoc-preamble"><h1>Module <code><span>Alpn</span></code></h1><p>ALPN support.</p><p><code>Alpn</code> depend on <code>http/af</code> &amp; <code>h2</code> and choose them because they share the same <a href="../Paf/module-type-RUNTIME/index.html"><code>Paf.RUNTIME</code></a> interface. <code>Alpn</code> does not require <code>ocaml-tls</code> so it's possible to use OpenSSL. It requires, at least:</p><ul><li>Something to extract ALPN result from the TLS <i>flow</i></li><li>Something to represent as the string the peer (useful for over-framework)</li><li>An injection function (available from <code>mimic</code>)</li></ul><p>In other words, <code>Alpn</code> did the only choice to trust on <code>http/af</code> &amp; <code>h2</code> to handle HTTP/1.0, HTTP/1.1 and H2 protocols.</p></header><div class="odoc-content"><div class="odoc-spec"><div class="spec type" id="type-capability" class="anchored"><a href="#type-capability" class="anchor"></a><code><span><span class="keyword">type</span> <span>'c capability</span></span><span> = </span></code><table><tr id="type-capability.Rd" class="anchored"><td class="def variant constructor"><a href="#type-capability.Rd" class="anchor"></a><code><span>| </span><span><span class="constructor">Rd</span> : <span><span>[ `read ]</span> <a href="#type-capability">capability</a></span></span></code></td></tr><tr id="type-capability.Wr" class="anchored"><td class="def variant constructor"><a href="#type-capability.Wr" class="anchor"></a><code><span>| </span><span><span class="constructor">Wr</span> : <span><span>[ `write ]</span> <a href="#type-capability">capability</a></span></span></code></td></tr></table></div></div><div class="odoc-spec"><div class="spec type" id="type-body" class="anchored"><a href="#type-body" class="anchor"></a><code><span><span class="keyword">type</span> body</span><span> = </span></code><table><tr id="type-body.Body_HTTP_1_1" class="anchored"><td class="def variant constructor"><a href="#type-body.Body_HTTP_1_1" class="anchor"></a><code><span>| </span><span><span class="constructor">Body_HTTP_1_1</span> : <span><span class="type-var">'c</span> <a href="#type-capability">capability</a></span> * <span><span class="type-var">'c</span> <span class="xref-unresolved">Httpaf</span>.Body.t</span> <span class="arrow">&#45;&gt;</span> <a href="#type-body">body</a></span></code></td></tr><tr id="type-body.Body_HTTP_2_0" class="anchored"><td class="def variant constructor"><a href="#type-body.Body_HTTP_2_0" class="anchor"></a><code><span>| </span><span><span class="constructor">Body_HTTP_2_0</span> : <span><span class="type-var">'c</span> <a href="#type-capability">capability</a></span> * <span><span class="type-var">'c</span> <a href="#type-h2_body">h2_body</a></span> <span class="arrow">&#45;&gt;</span> <a href="#type-body">body</a></span></code></td></tr></table></div></div><div class="odoc-spec"><div class="spec type" id="type-h2_body" class="anchored"><a href="#type-h2_body" class="anchor"></a><code><span><span class="keyword">and</span> <span>'c h2_body</span></span><span> = </span></code><table><tr id="type-h2_body.Wr" class="anchored"><td class="def variant constructor"><a href="#type-h2_body.Wr" class="anchor"></a><code><span>| </span><span><span class="constructor">Wr</span> : <span class="xref-unresolved">H2</span>.Body.Writer.t <span class="arrow">&#45;&gt;</span> <span><span>[ `write ]</span> <a href="#type-h2_body">h2_body</a></span></span></code></td></tr><tr id="type-h2_body.Rd" class="anchored"><td class="def variant constructor"><a href="#type-h2_body.Rd" class="anchor"></a><code><span>| </span><span><span class="constructor">Rd</span> : <span class="xref-unresolved">H2</span>.Body.Reader.t <span class="arrow">&#45;&gt;</span> <span><span>[ `read ]</span> <a href="#type-h2_body">h2_body</a></span></span></code></td></tr></table></div></div><div class="odoc-spec"><div class="spec type" id="type-response" class="anchored"><a href="#type-response" class="anchor"></a><code><span><span class="keyword">type</span> response</span><span> = </span></code><table><tr id="type-response.Response_HTTP_1_1" class="anchored"><td class="def variant constructor"><a href="#type-response.Response_HTTP_1_1" class="anchor"></a><code><span>| </span><span><span class="constructor">Response_HTTP_1_1</span> <span class="keyword">of</span> <span class="xref-unresolved">Httpaf</span>.Response.t</span></code></td></tr><tr id="type-response.Response_HTTP_2_0" class="anchored"><td class="def variant constructor"><a href="#type-response.Response_HTTP_2_0" class="anchor"></a><code><span>| </span><span><span class="constructor">Response_HTTP_2_0</span> <span class="keyword">of</span> <span class="xref-unresolved">H2</span>.Response.t</span></code></td></tr></table></div></div><div class="odoc-spec"><div class="spec type" id="type-request" class="anchored"><a href="#type-request" class="anchor"></a><code><span><span class="keyword">type</span> request</span><span> = </span></code><table><tr id="type-request.Request_HTTP_1_1" class="anchored"><td class="def variant constructor"><a href="#type-request.Request_HTTP_1_1" class="anchor"></a><code><span>| </span><span><span class="constructor">Request_HTTP_1_1</span> <span class="keyword">of</span> <span class="xref-unresolved">Httpaf</span>.Request.t</span></code></td></tr><tr id="type-request.Request_HTTP_2_0" class="anchored"><td class="def variant constructor"><a href="#type-request.Request_HTTP_2_0" class="anchor"></a><code><span>| </span><span><span class="constructor">Request_HTTP_2_0</span> <span class="keyword">of</span> <span class="xref-unresolved">H2</span>.Request.t</span></code></td></tr></table></div></div><div class="odoc-spec"><div class="spec type" id="type-reqd" class="anchored"><a href="#type-reqd" class="anchor"></a><code><span><span class="keyword">type</span> reqd</span><span> = </span></code><table><tr id="type-reqd.Reqd_HTTP_1_1" class="anchored"><td class="def variant constructor"><a href="#type-reqd.Reqd_HTTP_1_1" class="anchor"></a><code><span>| </span><span><span class="constructor">Reqd_HTTP_1_1</span> <span class="keyword">of</span> <span class="xref-unresolved">Httpaf</span>.Reqd.t</span></code></td></tr><tr id="type-reqd.Reqd_HTTP_2_0" class="anchored"><td class="def variant constructor"><a href="#type-reqd.Reqd_HTTP_2_0" class="anchor"></a><code><span>| </span><span><span class="constructor">Reqd_HTTP_2_0</span> <span class="keyword">of</span> <span class="xref-unresolved">H2</span>.Reqd.t</span></code></td></tr></table></div></div><div class="odoc-spec"><div class="spec type" id="type-headers" class="anchored"><a href="#type-headers" class="anchor"></a><code><span><span class="keyword">type</span> headers</span><span> = </span></code><table><tr id="type-headers.Headers_HTTP_1_1" class="anchored"><td class="def variant constructor"><a href="#type-headers.Headers_HTTP_1_1" class="anchor"></a><code><span>| </span><span><span class="constructor">Headers_HTTP_1_1</span> <span class="keyword">of</span> <span class="xref-unresolved">Httpaf</span>.Headers.t</span></code></td></tr><tr id="type-headers.Headers_HTTP_2_0" class="anchored"><td class="def variant constructor"><a href="#type-headers.Headers_HTTP_2_0" class="anchor"></a><code><span>| </span><span><span class="constructor">Headers_HTTP_2_0</span> <span class="keyword">of</span> <span class="xref-unresolved">H2</span>.Headers.t</span></code></td></tr></table></div></div><div class="odoc-spec"><div class="spec type" id="type-server_error" class="anchored"><a href="#type-server_error" class="anchor"></a><code><span><span class="keyword">type</span> server_error</span><span> = </span><span>[ </span></code><table><tr id="type-server_error.Bad_gateway" class="anchored"><td class="def constructor"><a href="#type-server_error.Bad_gateway" class="anchor"></a><code><span>| </span></code><code><span>`Bad_gateway</span></code></td></tr><tr id="type-server_error.Bad_request" class="anchored"><td class="def constructor"><a href="#type-server_error.Bad_request" class="anchor"></a><code><span>| </span></code><code><span>`Bad_request</span></code></td></tr><tr id="type-server_error.Exn" class="anchored"><td class="def constructor"><a href="#type-server_error.Exn" class="anchor"></a><code><span>| </span></code><code><span>`Exn <span class="keyword">of</span> exn</span></code></td></tr><tr id="type-server_error.Internal_server_error" class="anchored"><td class="def constructor"><a href="#type-server_error.Internal_server_error" class="anchor"></a><code><span>| </span></code><code><span>`Internal_server_error</span></code></td></tr></table><code><span> ]</span></code></div></div><div class="odoc-spec"><div class="spec type" id="type-info" class="anchored"><a href="#type-info" class="anchor"></a><code><span><span class="keyword">type</span> <span>('flow, 'edn) info</span></span><span> = </span><span>{</span></code><table><tr id="type-info.alpn" class="anchored"><td class="def record field"><a href="#type-info.alpn" class="anchor"></a><code><span>alpn : <span><span class="type-var">'flow</span> <span class="arrow">&#45;&gt;</span></span> <span>string option</span>;</span></code></td></tr><tr id="type-info.peer" class="anchored"><td class="def record field"><a href="#type-info.peer" class="anchor"></a><code><span>peer : <span><span class="type-var">'flow</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'edn</span>;</span></code></td></tr><tr id="type-info.injection" class="anchored"><td class="def record field"><a href="#type-info.injection" class="anchor"></a><code><span>injection : <span><span class="type-var">'flow</span> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Mimic</span>.flow;</span></code></td></tr></table><code><span>}</span></code></div><div class="spec-doc"><p>The type of information from a <code>'flow</code>:</p><ul><li><code>alpn</code> is a fonction which is able to extract the result of the negotiation between the client &amp; the server about which protocol we need to start</li><li><code>peer</code> returns a <code>string</code> representation of the given <code>'flow</code> to help to print out some logs about this client.</li><li><code>injection</code> is the function which wraps the given <code>'flow</code> to a <code>Mimic.flow</code>.</li></ul><p>For the last function, it can be done if you already registered the protocol with <code>mimic</code>. In that case, the second value given by <code>Mimic.register</code> helps you to <i>inject</i> your flow as a <code>Mimic.flow</code>:</p><pre><code>let _, protocol = Mimic.register ~name:&quot;my-protocol&quot; (module My_protocol)

let injection (flow : My_protocol.flow) : Mimic.flow =
  let module R = (val Mimic.repr protocol) in
  R.T flow</code></pre></div></div><div class="odoc-spec"><div class="spec value" id="val-service" class="anchored"><a href="#val-service" class="anchor"></a><code><span><span class="keyword">val</span> service : 
  <span><span><span>( <span class="type-var">'flow</span>, <span class="type-var">'edn</span> )</span> <a href="#type-info">info</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span>error_handler:
    <span>( <span><span class="type-var">'edn</span> <span class="arrow">&#45;&gt;</span></span> <span>?request:<a href="#type-request">request</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-server_error">server_error</a> <span class="arrow">&#45;&gt;</span></span> <span><span>( <span><a href="#type-headers">headers</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-body">body</a> )</span> <span class="arrow">&#45;&gt;</span></span> unit )</span> <span class="arrow">&#45;&gt;</span></span>
  <span>request_handler:<span>( <span><span class="type-var">'edn</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-reqd">reqd</a> <span class="arrow">&#45;&gt;</span></span> unit )</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>( <span><span class="type-var">'socket</span> <span class="arrow">&#45;&gt;</span></span>
    <span><span><span>( <span class="type-var">'flow</span>, <span>[&gt; `Closed <span><span>| `Msg</span> of string</span> ]</span> <span class="keyword">as</span> 'error )</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span> )</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>( <span><span class="type-var">'t</span> <span class="arrow">&#45;&gt;</span></span>
    <span><span><span>( <span class="type-var">'socket</span>, <span>[&gt; `Closed <span><span>| `Msg</span> of string</span> ]</span> <span class="keyword">as</span> 'error )</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span> )</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>( <span><span class="type-var">'t</span> <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="xref-unresolved">Lwt</span>.t</span> )</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'t</span> <a href="../Paf/index.html#type-service">Paf.service</a></span></span></code></div><div class="spec-doc"><p><code>service info ~error_handler ~request_handler connect accept close</code> creates a new <a href="../Paf/index.html#type-service"><code>Paf.service</code></a> over the <i>socket</i> <code>'t</code>. From the given implementation of <code>accept</code> and <code>close</code>, we are able to instantiate the <i>main loop</i>. Then, from the given <code>info</code>, we extract informations such the application layer protocol and choose which protocol we will use. Currently, if <code>info.alpn</code> returns:</p><ul><li><code>Some &quot;http/1.0&quot; | Some &quot;http/1.1&quot; | None</code>, we launch an <code>http/af</code> service</li><li><code>Some &quot;h2&quot;</code>, we launch an <code>h2</code> service</li></ul><p>The user is able to identify which protocol we launched by <code>resp_handler</code>. The returned service can be run with <a href="../Paf/index.html#val-serve"><code>Paf.serve</code></a>. Here is an example with <code>Lwt_unix.file_descr</code> and the TCP/IP transmission protocol (without ALPN negotiation):</p><pre><code>let _, protocol
  : Unix.sockaddr Mimic.value
    * (Unix.sockaddr, Lwt_unix.file_descr) Mimic.protocol
  = Mimic.register ~name:&quot;lwt-tcp&quot; (module TCP)

let accept t =
  Lwt.catch begin fun () -&gt;
    Lwt_unix.accept &gt;&gt;= fun (socket, _) -&gt;
    Lwt.return_ok socket
  end @@ function
  | Unix.Unix_error (err, f, v) -&gt;
    Lwt.return_error (`Unix (err, f, v))
  | exn -&gt; raise exn

let info =
  let module R = (val Mimic.register protocol) in
  { Alpn.alpn= const None
  ; Alpn.peer= (fun socket -&gt;
    sockaddr_to_string (Lwt_unix.getpeername socket))
  ; Alpn.injection=
    (fun socket -&gt; R.T socket) }

let service = Alpn.service info
  ~error_handler
  ~request_handler
  accept Lwt_unix.close

let fiber =
  let t = Lwt_unix.socket Unix.PF_INET Unix.SOCK_STREAM 0 in
  Lwt_unix.bind t (Unix.ADDR_INET (Unix.inet_addr_loopback, 8080))
  &gt;&gt;= fun () -&gt;
  let `Initialized th = Paf.serve
    ~sleep:(Lwt_unix.sleep &lt;.&gt; Int64.to_float)
    service t in th

let () = Lwt_main.run fiber</code></pre></div></div><div class="odoc-spec"><div class="spec type" id="type-client_error" class="anchored"><a href="#type-client_error" class="anchor"></a><code><span><span class="keyword">type</span> client_error</span><span> = </span><span>[ </span></code><table><tr id="type-client_error.Exn" class="anchored"><td class="def constructor"><a href="#type-client_error.Exn" class="anchor"></a><code><span>| </span></code><code><span>`Exn <span class="keyword">of</span> exn</span></code></td></tr><tr id="type-client_error.Malformed_response" class="anchored"><td class="def constructor"><a href="#type-client_error.Malformed_response" class="anchor"></a><code><span>| </span></code><code><span>`Malformed_response <span class="keyword">of</span> string</span></code></td></tr><tr id="type-client_error.Invalid_response_body_length_v1" class="anchored"><td class="def constructor"><a href="#type-client_error.Invalid_response_body_length_v1" class="anchor"></a><code><span>| </span></code><code><span>`Invalid_response_body_length_v1 <span class="keyword">of</span> <span class="xref-unresolved">Httpaf</span>.Response.t</span></code></td></tr><tr id="type-client_error.Invalid_response_body_length_v2" class="anchored"><td class="def constructor"><a href="#type-client_error.Invalid_response_body_length_v2" class="anchor"></a><code><span>| </span></code><code><span>`Invalid_response_body_length_v2 <span class="keyword">of</span> <span class="xref-unresolved">H2</span>.Response.t</span></code></td></tr><tr id="type-client_error.Protocol_error" class="anchored"><td class="def constructor"><a href="#type-client_error.Protocol_error" class="anchor"></a><code><span>| </span></code><code><span>`Protocol_error <span class="keyword">of</span> <span class="xref-unresolved">H2</span>.Error_code.t * string</span></code></td></tr></table><code><span> ]</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-run" class="anchored"><a href="#val-run" class="anchor"></a><code><span><span class="keyword">val</span> run : 
  <span>sleep:<a href="../Paf/index.html#type-sleep">Paf.sleep</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?alpn:string <span class="arrow">&#45;&gt;</span></span>
  <span>error_handler:<span>( <span><span class="type-var">'edn</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-client_error">client_error</a> <span class="arrow">&#45;&gt;</span></span> unit )</span> <span class="arrow">&#45;&gt;</span></span>
  <span>response_handler:<span>( <span><span class="type-var">'edn</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-response">response</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-body">body</a> <span class="arrow">&#45;&gt;</span></span> unit )</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'edn</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>[ <span>`V1 of <span class="xref-unresolved">Httpaf</span>.Request.t</span> <span><span>| `V2</span> of <span class="xref-unresolved">H2</span>.Request.t</span> ]</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Mimic</span>.flow <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>( <a href="#type-body">body</a>, <span>[&gt; <span>`Msg of string</span> ]</span> )</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>run ~sleep ?alpn ~error_handler ~response_handler edn req flow</code> tries communitate to <code>edn</code> via <code>flow</code> with a certain protocol according to the given <code>alpn</code> value and the given request. It returns the body of the request to allow the user to write on it (and communicate then with the server).</p><p><code>run</code> does only the ALPN dispatch. It does not instantiate the connection and it does not try to upgrade the protocol. It just choose the right HTTP protocol according to:</p><ul><li>the given <code>alpn</code> value</li><li>the given <code>request</code> (if you want to communicate via HTTP/1.1 or H2)</li></ul><p>Here is an example with <code>mimic</code>:</p><pre><code>let run uri request =
  let ctx = ctx_of_uri uri in
  (* See Mimic for more details. *)
  Mimic.resolve ctx &gt;&gt;= function
  | Error _ as err -&gt; Lwt.return err
  | Ok flow -&gt;
      run
        ~sleep:(Lwt_unix.sleep &lt;.&gt; Int64.to_float)
        ?alpn:None ~error_handler ~response_handler uri request flow</code></pre></div></div></div></body></html>